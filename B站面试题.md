**1.快速居中对齐**      display:flex   margin:auto

**2.margin和padding有什么不同？**  作用对象

**3.vw和百分比**    百分比有继承关系，vw只和设备的宽度有关系(1/100视口宽度)

**4.行内元素和块级元素**   设置宽高，一行显示，继承关系

**5.谷歌支持小字体**    transform:scale(缩放)

====================================================================

**1.let和var**

var的问题:

1)声明提升，先上车后买票 

2)没有局部作用域，红杏出墙 

3)声明覆盖，套牌车 

**2.深拷贝和浅拷贝**

数组和对象的赋值都叫做浅拷贝             解构赋值针对一维数组和对象可以看做深拷贝，多维的是浅拷贝

=======================================================================

**1.在游览器中输入url并回车后都发生了什么？**

https://baidu.com          url:统一资源定位符，ip的一个映射

https：传输协议(http和tcp加了一层TSL或者SSL的安全层)  www服务器    baidu.com域名

ping (测试连接)

1)第一次访问  ---------DNS域名系统匹配对应的ip

2)解析url=>DNS域名系统匹配真实的ip=>拿到真实的ip=>建立连接(TCP三次握手)=>拿数据，渲染页面=>四次挥手

3)第二次访问，将域名解析的IP存在本地=》读取游览器缓存

**2.游览器渲染过程** 

 html->dom树(大块，不是第一次加载就建造的display:none)  和css->结构体并行构建==>render.tree=>计算布局信息=》UI引擎渲染=》用户所见页面

**3.日常开发哪些点做性能优化**

a.加载(主要优化方向)

​      1)减少http请求(雪碧图，文件合并)                       2)减少文件大小(资源压缩，图片压缩，代码压缩)

​      3)CDN(第三方库,大文件和大图用链接来引入)     4)SSR服务端渲染，预渲染                  5.懒加载     6.分包

b.性能

​       1)减少DOM操作，避免回流重绘，文档碎片

**4.性能优化到底是什么**

**执行效率**(讨论while和for哪个快，if/else和三元运算符谁快)对**性能优化的作用微乎其微**

页面加载性能(加载时间，用户体验)     >     

 动画与操作性能(流畅无卡顿)     >      大片DOM切换，变动首选tranlate和定位，脱离文档流，避免大幅度的回流

内存占用(内存占用过大)      >      

电量消耗

==================================================================

**1.图片懒加载**

判断图片是否在视口之内，offsettop大于视口高度的话，就表明设备宽度还没有划到这张图片，我们就可以用一些其他统一的图片代替        

手写懒加载代码  伪代码

```javascript
<img src="./默认加载中图片.gif" data-src="./真实图片1.png" />
<img src="./默认加载中图片.gif" data-src="./真实图片2.png" />

定义num获取img的图片数量
定义img获取实际的所有图片标签
定义n=0

定义函数{
    获取视口高度(可见区域)
    获取滚动距离
    获取每张图片当前的位置
    
  循环遍历每个图片
  如果图片的offsetTop<视口+scrollTop
    如果img的src等于默认图片
      就将真实的，放在自定义属性里的src赋值给真实的src
   
   n=i+1 //防止重复加载
}
```

==================================================================================================

**1.this指向问题**

```javascript
conasole.log(this)        //打印window
----------------------------------------------------------
funtion a(){   
   conasole.log(this)     //打印window(a挂载在window下)
}          
a()      
-----------------------------------------------------------
this永远指向他的上一级(调用者)===>谁调用指向谁法则并不适用
1、以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window。比如`fun();`相当于`window.fun();`
2、以方法的形式调用时，this 指向调用方法的那个对象
3、以构造函数的形式调用时，this 指向实例对象
4、以事件绑定函数的形式调用时，this 指向**绑定事件的对象**
5、使用 call 和 apply 调用时，this 指向指定的那个对象
-----------------------------------------------------------
var id=66
function a(){
    setTimeout(()=>{
        //箭头函数没有作用域，所以没有this,其this指向上一层(外层)，外部函数调用等于window调用
        console.log(this.id)//66
    },500)
}
a({id:22})
//如何指向22呢
call     apply()    bind()
call和apply()只是传参上的区别，改变之后执行一次    call=>{}  apply=>[]    
伪代码:
let dog={name:xxx,eat方法  }
let cat={name:xx}
//我们想让猫也调用狗的eat方法该怎么做呢
dog.eat.call(cat,'鱼','肉')
dog.eat.call(cat,['鱼','肉'])
bind()不调用，只改变this指向
主要应用场景:
call 经常做继承。
apply 经常跟数组有关系，比如借助于数学对象实现数组最大值最小值。
bind 不调用函数，但是还想改变this指向，比如改变定时器内部的this指向。
```

2.**闭包**

```javascript
//为什么要引入闭包
避免变量被污染        私有化           保存变量
//闭包的应用场景
防抖，节流，库的封装
function myModule() {
    //私有数据
    var msg = 'Qinguyihao Haha'

    //操作私有数据的函数
    function doSomething() {
        console.log('doSomething(
                   ) ' + msg.toUpperCase()); //字符串大写
    }

    function doOtherthing() {
        console.log('doOtherthing() ' + msg.toLowerCase()) //字符串小写
    }

    //通过【对象字面量】的形式进行包裹，向外暴露多个函数
    return {
        doSomething1: doSomething,
        doOtherthing2: doOtherthing
    }
}
上方代码中，外界只能通过doSomething1和doOtherthing2来操作里面的数据，但不让外界看到里面的具体实现。
```

**3.new**

```javascript
new关键字的一瞬间做了什么？
1.new 操作符新建了一个空对象，
let obj=Object.create(null)      let obj={}
//他们都是空对象，有什么区别
//obj是没有原型链的，纯净的对象，_proto_,作用(存储值而不用调其中的方法，用for in取值场景下，效率更高 )
2.这个对象原型指向构造函数的 prototype，
obj._proto_=Person,prototype
3.改变this指向
let result =Person.call(obj)
4.判断返回值类型
if(typeof(result)=="object"){
    persol1=result
}
```

4.**事件委托**

```
不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判 断事件发生元素 DOM 的类型，来做出不同的响应。
```

