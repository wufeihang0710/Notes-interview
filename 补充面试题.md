##### 1.v-for为什么要使用key

key 的作用主要是为了高效的更新虚拟 DOM。本质:给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，

Vue 默认按照“就地更新”的策略来更新通过 `v-for` 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。默认模式是高效的，但**只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况**。





##### 2.this的指向问题

```javascript
var a=11;
function test2(){
console.log(this) //此时输出的this是test2本身而不是windows  
this.a=22;
let b=()=>{console.log(this.a)}
b();
}
var x=new test2();//构建对象
------------------------------------------------------------
/* 例2 */
var name = '泰罗';
var obj = {
    name: '光太郎',
    sayName: function(){
        return function(){  //这里的this指向了window
            console.log(this.name); /* 泰罗 */
        }
    }
}
obj.sayName()(); /* 我们知道第一个()是由obj调用的，第二个括号，是由window调用的 */
```

##### 3.js类型的判断

**typeof**：**专门用于判断变量属于那种**基本类型**，或者变量**是否为引用类型，无法判断出变量属于具体哪种引用类型。对于所有引用类型，只有两种返回值：function、object      注意:null会判断为object类型

**instanceof**：**用于判断**引用类型**变量属于具体哪种类型的**实例。      检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

```javascript
const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true
var str1 = 'hello world'
str1 instanceof String // false
var str2 = new String('hello world')
str2 instanceof String // true
```

**Object.prototype.toString.call(obj).slice(8,-1)**：可以判断**任意类型**的数据。加一个call是因为不论是Function还是Array，继承了toString()方法后都对其进行了重写，根据原型链我们知道，一个方法自身存在就不会沿着原型链寻找。我们知道，对一个Function调用toString打印的是方法体的内容，对一个Array调用toString打印的是所有元素拼接的字符串。所以我们需要调用真正存在于Object原型身上的toString方法（打印数据类型）。      

**constructor**：**可以判断**任意类型的数据，但有被重写的风险，因此不建议使用。



##### 4.数组去重

```javascript
1.Array.from(new Set('传入数组'))
2.利用indexOf去重，创建新数组，遍历原数组，如果利用indexOf查找新创建的数组，如果为0就push
3.Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。
关键代码:
function newArrFn (arr) {
      // 利用对象属性名不能重复这一特点
      // 如果对象中不存在，就可以给 push 进去
      let newArr = []
      let obj = {}
      for(let i = 0;i<arr.length;i++){
        if (!obj[arr[i]]) {
          newArr.push(arr[i])
          obj[arr[i]] = 1
        } else {
          obj[arr[i]] ++
        }
      };

```

###### 5.作用域和作用域链

作用域:就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是**隔离变量**，不同作用域下同名变量不会有冲突。

作用域链:根据在内部函数可以访问外部函数变量的这种机制，用**链式查找决定哪些数据能被内部函数访问,来决定取那个值**，就称作作用域链;**(就近原则)**



##### 6.null和undefined的区别

总的来说 `null` 和 `undefined` 都代表空，主要区别在于 `undefined` 表示尚未初始化的变量的值，而 `null` 表示该变量有意缺少对象指向。

- `undefined`

- - 这个变量从根本上就没有定义
  - 隐藏式 空值

- `null`

- - 这个值虽然定义了，但它并未指向任何内存中的对象
  - 声明式 空值

##### 7.虚拟DOM

在react，vue等技术出现之前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的**虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树**，那么每次 **dom 的更改就变成了 js 对象的属性的更改**，这样一来就能查找 js 对象的属性变化要比查询 dom 树的性能开销小。

用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了。Virtual DOM 本质上**就是在 JS 和 DOM 之间做了一个缓存**

##### 8.原型和原型链，prototype,__proto__区别

具体查看文档笔记

##### 9.**$route 和 $router 的区别是什么？**

 $router 为 VueRouter 的实例，是一个**全局路由对象**，包含了路由跳转的方法、钩子函数等。

$route 是路由信息对象，每一个路由都会有一个 route 对象，是一个局部对象，包含 path，params，hash，query，fullPath，matched，name ,meta等路由信息参数。

##### 10.文件引入样式

**link和@import的区别**

link除了引入样式，还可以引入图片等资源，@import只能引入样式

link是和页面同时加载的，而@import是等页面加载完毕后在加载

link没有兼容性问题，而@import是ES6新增，部分游览器不支持

link的权重比@import高

##### 为什么link用href获取资源 script和img用src

src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。

- src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素

当浏览器解析到该元素时，**会暂停其他资源的下载和处理**，直到将该资源加载、编译、执行完毕，图片和框架 等元素也如此，类似于将所指向资源嵌入当前标签内。**这也是为什么将js脚本放在底部而不是头部**

- href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接,在文档中添加link标签，浏览器会识别该文档为css文件，就会并行下载资源并且**不会**停止对当前文档的处理。

##### 11.闭包

**什么是闭包:**闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用

**闭包的特征**:子函数所在的父函数的作用域不会被释放,当在一个函数内定义另外一个函数就会产生闭包。

**为什么要用闭包:**

**匿名自执行函数：**我们知道所有的变量，如果不加上 var 关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用 var 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。

**结果缓存：**我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。

**封装：**实现类和继承等。

### 前端安全问题

1. **XSS/CSS（跨站脚本攻击）**

> XSS又叫CSS（Cross Site Script），跨站脚本攻击：攻击者在目标网站植入恶意脚本（js / html），用户在浏览器上运行时可以获取用户敏感信息（cookie / session）、修改web页面以欺骗用户、与其他漏洞相结合形成蠕虫等。

浏览器遇到 html 中的 script 标签时，会解析并执行其中的js代码

针对这种情况，我们对特殊字符进行转译就好了（vue/react等主流框架已经避免类似问题，vue举例：不能在template中写script标签，无法在js中通过ref或append等方式动态改变或添加script标签）

XSS类型：

- 持久型XSS：将脚本植入到服务器上，从而导致每个访问的用户都会执行

- 场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。
- 攻击步骤：
  - i）攻击者将恶意代码提交到目标网站的数据库中
  - ii）用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在HTML中返回给浏览器
  - iii）用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行
  - iv）恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作



- 非持久型XSS：对个体用户某url的参数进行攻击
- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。
- 攻击步骤：
  - i）攻击者构造出特殊的 URL，其中包含恶意代码。
  - ii）用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  - iii）用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

防御措施（对用户输入内容和服务端返回内容进行过滤和转译）

- 现代大部分浏览器都自带 XSS 筛选器，vue / react 等成熟框架也对 XSS 进行一些防护
- 对用户输入内容和服务端返回内容进行过滤和转译
- 重要内容加密传输
- 合理使用get/post等请求方式
- 对于URL携带参数谨慎使用
- 我们无法做到彻底阻止，但是能增加黑客攻击成本，当成本与利益不符时自然会降低风险



+ **CSRF / XSRF（跨站请求伪造）**

> 你可以这么理解 CSRF 攻击：攻击者盗用了你的身份，以你的名义进行恶意请求。它能做的事情有很多包括：以你的名义发送邮件、发信息、盗取账号、购买商品、虚拟货币转账等。总结起来就是：个人隐私暴露及财产安全问题。

```javascript
/*
 * 阐述 CSRF 攻击思想：（核心2和3）
 * 1、浏览并登录信任网站（举例：淘宝）
 * 2、登录成功后在浏览器产生信息存储（举例：cookie）
 * 3、用户在没有登出淘宝的情况下，访问危险网站
 * 4、危险网站中存在恶意代码，代码为发送一个恶意请求（举例：购买商品/余额转账）
 * 5、携带刚刚在浏览器产生的信息进行恶意请求
 * 6、淘宝验证请求为合法请求（区分不出是否是该用户发送）
 * 7、达到了恶意目标
 */
```

防御措施（推荐添加token / HTTP头自定义属性）

- 涉及到数据修改操作严格使用 post 请求而不是 get 请求
- HTTP 协议中使用 Referer 属性来确定请求来源进行过滤（禁止外域）
- **请求地址添加 token ，使黑客无法伪造用户请求**
- **HTTP 头自定义属性验证**（类似上一条）
- 显示验证方式：添加验证码、密码等

**URL的加密解密:**

**参考答案**：

JavaScript中有三个可以对字符串编码的函数，分别是： escape,encodeURI,encodeURIComponent，相应3个解码函数：unescape,decodeURI,decodeURIComponent 。

**三种方式的特点：**

escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。

而encodeURI() 用于编码整个URI,因为URI中的合法字符都不会被编码转换。

encodeURIComponent方法在编码单个URIComponent（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。





### 网络请求

#### 5.1 跨域是什么？如何解决跨域？

**参考答案**：

1.什么是同源策略及其限制内容？

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

**同源策略限制内容有：**

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求发送后，结果被浏览器拦截了

但是有三个标签是允许跨域加载资源：

- <img src='xxx'>

- <link href='xxx'>

- <script src='xxx'>

跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。

1. 跨域解决方案

   解决方案有jsonp、cors、postMessage、websocket、Node中间件代理(两次跨域)、nginx反向代理、window.name + iframe、location.hash + iframe、document.domain + iframe，CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案，JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。日常工作中，用得比较多的跨域方案是cors和nginx反向代理

##### 5.2 jsonp原理

**参考答案**：

利用<script>标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定 需要对方的服务器做支持才可以。

**解析**：

1. JSONP和AJAX对比

   JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）

2. JSONP优缺点

   JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**

#### 5.5 常见http status

**参考答案：**

**1XX系列**：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。

**2XX系列**：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。

**3XX系列**：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。这系列中最常见的有301、302状态码。

**4XX系列**：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。

**5xx系列**：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。

**2开头 （请求成功）表示成功处理了请求的状态代码。**

- 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
- 201 （已创建） 请求成功并且服务器创建了新的资源。
- 202 （已接受） 服务器已接受请求，但尚未处理。
- 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
- 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
- 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
- 206 （部分内容） 服务器成功处理了部分 GET 请求。

**3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。**

- 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
- 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
- 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
- 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
- 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
- 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

**4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。**

- 400 （错误请求） 服务器不理解请求的语法。
- 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403 （禁止） 服务器拒绝请求。
- 404 （未找到） 服务器找不到请求的网页。
- 405 （方法禁用） 禁用请求中指定的方法。
- 406 （不接受） 无法使用请求的内容特性响应请求的网页。
- 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
- 408 （请求超时） 服务器等候请求时发生超时。
- 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
- 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
- 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
- 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
- 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
- 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
- 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
- 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
- 417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

**5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。**

- 500 （服务器内部错误） 服务器遇到错误，无法完成请求。
- 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
- 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
- 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
- 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
- 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

#### 5.6 http和https

#### 5.7 http1.x 和http2.x区别

#### 5.8 http请求方式

### 业务场景

**1.Cookie + Session 登录**

HTTP 是一种无状态的协议，客户端每次发送请求时，首先要和服务器端建立一个连接，在请求完成后又会断开这个连接。这种方式可以节省传输时占用的连接资源，但同时也存在一个问题：**每次请求都是独立的**，服务器端无法判断本次请求和上一次请求是否来自同一个用户，进而也就无法判断用户的登录状态。

为了解决 HTTP 无状态的问题，*Lou Montulli* 在 1994 年的时候，推出了 Cookie。

> Cookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。

有了 Cookie 之后，服务器端就能够获取到客户端传递过来的信息了，如果需要对信息进行验证，还需要通过 Session。

> 客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个便是 Session 对象。

有了 Cookie 和 Session 之后，我们就可以进行登录认证了。

**Cookie + Session 实现流程**

Cookie + Session 的登录方式是最经典的一种登录方式，现在仍然有大量的企业在使用。

1. ![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646127741227/31A6FC971075B9EF9B057857E91BB945)用户访问a.com/pageA，并输入密码登录。
2. 服务器验证密码无误后，会创建 SessionId，并将它保存起来。
3. 服务器端响应这个 HTTP 请求，并通过 Set-Cookie 头信息，将 SessionId 写入 Cookie 中。

> 服务器端的 SessionId 可能存放在很多地方，例如：内存、文件、数据库等。

第一次登录完成之后，后续的访问就可以直接使用 Cookie 进行身份验证了：

1. ![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646127757097/13D290B6D5EA6B25592EBB6B6A999BCC)用户访问a.com/pageB页面时，会自动带上第一次登录时写入的 Cookie。
2. 服务器端比对 Cookie 中的 SessionId 和保存在服务器端的 SessionId 是否一致。
3. 如果一致，则身份验证成功。

Cookie + Session 存在的问题

虽然我们使用 Cookie + Session 的方式完成了登录验证，但仍然存在一些问题：

- 由于服务器端需要对接大量的客户端，也就需要存放大量的 SessionId，这样会导致服务器压力过大。
- 如果服务器端是一个集群，为了同步登录态，需要将 SessionId 同步到每一台机器上，无形中增加了服务器端维护成本。
- 由于 SessionId 存放在 Cookie 中，所以无法避免 CSRF 攻击。

**2.Token 登录**

为了解决 Session + Cookie 机制暴露出的诸多问题，我们可以使用 Token 的登录方式。

> Token 是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登录后，服务器会生成一个 Token 并返回给客户端，客户端后续访问时，只需带上这个 Token 即可完成身份认证。

**Token 机制实现流程**

用户首次登录时：

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646127770626/7120D4E73F93A339D0DFCFCF35A4412B)

1. 用户输入账号密码，并点击登录。
2. 服务器端验证账号密码无误，创建 Token。
3. 服务器端将 Token 返回给客户端，由***客户端自由保存\***。

后续页面访问时：

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646127785481/6C223F76A9F234FF36387C1C70DE1C03)

1. 用户访问a.com/pageB时，带上第一次登录时获取的 Token。
2. 服务器端验证 Token ，有效则身份验证成功。

Token 机制的特点

根据上面的案例，我们可以分析出 Token 的优缺点：

- 服务器端不需要存放 Token，所以不会对服务器端造成压力，即使是服务器集群，也不需要增加维护成本。
- Token 可以存放在前端任何地方，可以不用保存在 Cookie 中，提升了页面的安全性。
- Token 下发之后，只要在生效时间之内，就一直有效，如果服务器端想收回此 Token 的权限，并不容易。